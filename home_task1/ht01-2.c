/*Написать функцию getline2, которая считывает строку текста (до символа \n) из заданного дескриптора потока.
char *getline2(FILE *f);
Функция считывает последовательность байтов неограниченной длины до символа ‘\n’ или до конца файла. В последовательности байтов не может встречаться байт ‘\0’. Функция возвращает указатель на строку (то есть завершающуюся байтом 0), выделенную в динамической памяти. В конце строки сохраняется байт ‘\n’, если он был считан из потока. Если из потока не был считан ни один байт но сразу был получен признак конца файла, функция getline должна вернуть NULL.
Соблюдайте стиль оформления программ!
Опции компилятора gcc, с которыми компилируется ваша программа, доступны здесь.
За каждую неправильную попытку (не прошедшую все тесты) снимается 4 балла.
Первые решившие получают бонус к баллам (12-8-4).
Через каждые семь дней с момента открытия из максимального балла будет вычитаться 20 баллов.
Итоговая формула: MAX(0;50+BONUS(12;8;4)-4*ATTEMPTS-20/7d).*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char *getline2(FILE *f)
{
    char *str = NULL;
    int c, i = 0;
    int mem_free = 4;
    c = fgetc(f);
    if (c == EOF)
        return str;
    str = malloc(mem_free);
    str[i] = c;
    if (c == '\n'){
        str[i + 1] = '\0';
        return str;
    }
    while ((c = fgetc(f)) != EOF){
        if((i + 1) == mem_free){
            mem_free *= 2;
            str = realloc(str, mem_free * sizeof(str[0]));
        }
        i++;
        str[i] = c;
        if (c == '\n'){
            break;
        }
    }
    if((i + 1) == mem_free){
        mem_free *= 2;
        str = realloc(str, mem_free * sizeof(str[0]));
    }
    str[i + 1] = '\0';
    return str;
}

